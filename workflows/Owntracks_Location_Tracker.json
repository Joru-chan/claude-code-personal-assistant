{
  "updatedAt": "2026-02-19T16:49:46.474Z",
  "createdAt": "2026-02-18T19:31:58.189Z",
  "id": "lOVfBNjOpIc3hZxZ",
  "name": "Owntracks Location Tracker",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "owntracks",
        "options": {
          "rawBody": false
        }
      },
      "id": "webhook-owntracks",
      "name": "Webhook - Owntracks",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        256,
        304
      ],
      "webhookId": "owntracks-location"
    },
    {
      "parameters": {
        "jsCode": "// Owntracks Location Data Filter and Transformer\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst MIN_ACCURACY = 50;  // meters\nconst MIN_DISTANCE = 20;  // meters\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// COMPREHENSIVE DATA EXTRACTION WITH DEBUGGING\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconsole.log('ğŸ” RAW INPUT STRUCTURE:');\nconsole.log('$input:', JSON.stringify($input, null, 2));\nconsole.log('$input.all():', JSON.stringify($input.all(), null, 2));\n\n// Try multiple extraction methods\nlet item = null;\nlet extractionMethod = 'unknown';\n\n// Method 1: Direct json access\nif ($input.item && $input.item.json) {\n  item = $input.item.json;\n  extractionMethod = 'direct-json';\n  console.log('âœ“ Extracted via direct JSON access');\n}\n\n// Method 2: First item from all()\nif (!item && $input.all().length > 0) {\n  item = $input.all()[0].json;\n  extractionMethod = 'first-item-json';\n  console.log('âœ“ Extracted via first item JSON');\n}\n\n// Method 3: Check if data is in body\nif (!item && $input.item && $input.item.json && $input.item.json.body) {\n  item = $input.item.json.body;\n  extractionMethod = 'body-nested';\n  console.log('âœ“ Extracted via body nesting');\n}\n\n// Method 4: Check if data is in webhook payload\nif (!item && $input.item && $input.item.json && $input.item.json.payload) {\n  item = $input.item.json.payload;\n  extractionMethod = 'payload-nested';\n  console.log('âœ“ Extracted via payload nesting');\n}\n\n// Method 5: Direct access to raw data\nif (!item) {\n  item = $input.item || {};\n  extractionMethod = 'raw-item';\n  console.log('âœ“ Using raw item data');\n}\n\nconsole.log('ğŸ“ Extracted data via method:', extractionMethod);\nconsole.log('ğŸ“ Extracted item data:', JSON.stringify(item, null, 2));\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// FLEXIBLE COORDINATE EXTRACTION\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nfunction extractCoordinates(data) {\n  const possibilities = [\n    // Standard Owntracks format\n    { lat: data.lat, lon: data.lon },\n    { lat: data.latitude, lon: data.longitude },\n    \n    // Nested in location object\n    { lat: data.location?.lat, lon: data.location?.lon },\n    { lat: data.location?.latitude, lon: data.location?.longitude },\n    \n    // Query parameters (if webhook passes as query)\n    { lat: data.query?.lat, lon: data.query?.lon },\n    { lat: data.query?.latitude, lon: data.query?.longitude },\n    \n    // Body parameters\n    { lat: data.body?.lat, lon: data.body?.lon },\n    { lat: data.body?.latitude, lon: data.body?.longitude },\n    \n    // Headers (unlikely but possible)\n    { lat: data.headers?.lat, lon: data.headers?.lon },\n    { lat: data.headers?.latitude, lon: data.headers?.longitude },\n    \n    // Params\n    { lat: data.params?.lat, lon: data.params?.lon },\n    { lat: data.params?.latitude, lon: data.params?.longitude },\n  ];\n  \n  for (let i = 0; i < possibilities.length; i++) {\n    const coords = possibilities[i];\n    if (coords.lat !== undefined && coords.lon !== undefined && \n        coords.lat !== null && coords.lon !== null &&\n        !isNaN(parseFloat(coords.lat)) && !isNaN(parseFloat(coords.lon))) {\n      console.log(`âœ“ Found coordinates via method ${i + 1}: lat=${coords.lat}, lon=${coords.lon}`);\n      return {\n        latitude: parseFloat(coords.lat),\n        longitude: parseFloat(coords.lon)\n      };\n    }\n  }\n  \n  console.log('âŒ No valid coordinates found in any extraction method');\n  return { latitude: null, longitude: null };\n}\n\nconst coordinates = extractCoordinates(item);\n\n// Extract other Owntracks data with fallbacks\nconst data = {\n  type: item._type || item.type || 'location',\n  latitude: coordinates.latitude,\n  longitude: coordinates.longitude,\n  accuracy: parseFloat(item.acc || item.accuracy) || null,\n  timestamp: parseInt(item.tst || item.timestamp) || null,\n  altitude: parseFloat(item.alt || item.altitude) || null,\n  velocity: parseFloat(item.vel || item.velocity) || null,\n  battery: parseInt(item.batt || item.battery) || null,\n  tracker_id: item.tid || item.tracker_id || item.trackerId || null,\n  trigger: item.t || item.trigger || null\n};\n\nconsole.log('ğŸ¯ Processed data:', JSON.stringify(data, null, 2));\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// VALIDATION\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst validationErrors = [];\n\nif (data.latitude === null || data.longitude === null) {\n  validationErrors.push(`Missing latitude or longitude - lat: ${data.latitude}, lon: ${data.longitude}`);\n  console.log('âŒ Available keys in item:', Object.keys(item));\n  console.log('âŒ Item structure analysis:');\n  for (const key in item) {\n    console.log(`  ${key}: ${typeof item[key]} = ${JSON.stringify(item[key])}`);\n  }\n}\n\nif (data.latitude !== null && (data.latitude < -90 || data.latitude > 90)) {\n  validationErrors.push('Invalid latitude: ' + data.latitude);\n}\n\nif (data.longitude !== null && (data.longitude < -180 || data.longitude > 180)) {\n  validationErrors.push('Invalid longitude: ' + data.longitude);\n}\n\nif (validationErrors.length > 0) {\n  console.error('âŒ Validation errors:', validationErrors);\n  return {\n    json: {\n      error: 'Validation failed',\n      details: validationErrors,\n      extraction_method: extractionMethod,\n      available_keys: Object.keys(item),\n      raw_data: item,\n      skip: true\n    }\n  };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// FILTERING LOGIC\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst shouldSkip = [];\n\n// Filter 1: GPS Accuracy\nif (data.accuracy && data.accuracy > MIN_ACCURACY) {\n  shouldSkip.push(`Low accuracy: ${data.accuracy}m > ${MIN_ACCURACY}m`);\n}\n\n// Filter 2: Ignore certain trigger types if needed\nconst ignoredTriggers = [];  // e.g., ['p'] to ignore pings\n\nif (data.trigger && ignoredTriggers.includes(data.trigger)) {\n  shouldSkip.push(`Ignored trigger type: ${data.trigger}`);\n}\n\nif (shouldSkip.length > 0) {\n  console.log('â­ï¸  Skipping location update:', shouldSkip);\n  return {\n    json: {\n      skip: true,\n      reason: shouldSkip,\n      data: data\n    }\n  };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// TRANSFORM FOR POKE\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// Convert timestamp to ISO format\nconst timestamp = data.timestamp\n  ? new Date(data.timestamp * 1000).toISOString()\n  : new Date().toISOString();\n\n// Format data for Poke API\nconst pokePayload = {\n  type: 'location_update',\n  source: 'owntracks',\n  timestamp: timestamp,\n  location: {\n    latitude: data.latitude,\n    longitude: data.longitude,\n    accuracy: data.accuracy,\n    altitude: data.altitude,\n    velocity: data.velocity\n  },\n  device: {\n    tracker_id: data.tracker_id,\n    battery: data.battery,\n    trigger: data.trigger\n  },\n  metadata: {\n    raw_timestamp: data.timestamp,\n    processed_at: new Date().toISOString(),\n    extraction_method: extractionMethod\n  }\n};\n\nconsole.log('âœ… Location update passed filters');\nconsole.log('ğŸ“¤ Sending to Poke:', JSON.stringify(pokePayload, null, 2));\n\nreturn {\n  json: {\n    skip: false,\n    source: 'owntracks',\n    type: data.type,\n    coordinates: {\n      latitude: data.latitude,\n      longitude: data.longitude\n    },\n    device: {\n      tracker_id: data.tracker_id,\n      battery: data.battery\n    },\n    extraction_method: extractionMethod,\n    poke_payload: pokePayload,\n    original_data: data\n  }\n};"
      },
      "id": "filter-location",
      "name": "Filter Location Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        304
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.skip }}"
            }
          ]
        }
      },
      "id": "check-skip",
      "name": "Should Send?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        656,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format for Poke Webhook - Improved with Edge Case Handling\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\ntry {\n  // Validate input exists\n  const item = $input.first();\n  \n  if (!item) {\n    console.error('âŒ No input data received');\n    return [{\n      json: {\n        message: JSON.stringify({\n          error: 'No input data',\n          source: \"owntracks\",\n          timestamp: new Date().toISOString()\n        })\n      }\n    }];\n  }\n\n  console.log('ğŸ“¥ Input data:', JSON.stringify(item, null, 2));\n\n  // Safely extract data with defaults\n  const json = item.json || {};\n  \n  // Validate required fields exist\n  const source = json.source || 'owntracks';\n  const type = json.type || 'location';\n  \n  // Safely extract coordinates with validation\n  const coordinates = json.coordinates || {};\n  const hasValidCoordinates = \n    coordinates.latitude !== undefined && \n    coordinates.longitude !== undefined &&\n    coordinates.latitude !== null &&\n    coordinates.longitude !== null &&\n    !isNaN(coordinates.latitude) &&\n    !isNaN(coordinates.longitude);\n  \n  if (!hasValidCoordinates) {\n    console.error('âŒ Invalid or missing coordinates:', coordinates);\n    return [{\n      json: {\n        message: JSON.stringify({\n          error: 'Invalid coordinates',\n          source: source,\n          received: coordinates,\n          timestamp: new Date().toISOString()\n        })\n      }\n    }];\n  }\n  \n  // Safely extract device info with defaults\n  const device = json.device || {};\n  const deviceData = {\n    tracker_id: device.tracker_id || null,\n    battery: device.battery !== undefined ? device.battery : null\n  };\n  \n  // Build the location data object\n  const locationData = {\n    source: source,\n    type: type,\n    coordinates: {\n      latitude: parseFloat(coordinates.latitude),\n      longitude: parseFloat(coordinates.longitude)\n    },\n    device: deviceData\n  };\n  \n  // Stringify and validate JSON output\n  let messageString;\n  try {\n    messageString = JSON.stringify(locationData);\n  } catch (stringifyError) {\n    console.error('âŒ Error stringifying location data:', stringifyError);\n    messageString = JSON.stringify({\n      error: 'Stringify failed',\n      source: source,\n      timestamp: new Date().toISOString()\n    });\n  }\n  \n  console.log('âœ… Formatted message for Poke:', messageString);\n  \n  // Return in the required format\n  return [{\n    json: {\n      message: messageString\n    }\n  }];\n  \n} catch (error) {\n  console.error('âŒ Unexpected error in Format for Poke Webhook:', error);\n  console.error('Error stack:', error.stack);\n  console.error('Input data:', JSON.stringify($input.all(), null, 2));\n  \n  // Always return valid format even on error\n  return [{\n    json: {\n      message: JSON.stringify({\n        error: error.message || 'Unknown error',\n        source: \"owntracks\",\n        timestamp: new Date().toISOString(),\n        stack: error.stack\n      })\n    }\n  }];\n}"
      },
      "id": "format-poke-webhook",
      "name": "Format for Poke Webhook",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://poke.com/api/v1/inbound-sms/webhook",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify($json.message) }}",
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          },
          "timeout": 10000
        }
      },
      "id": "send-to-poke",
      "name": "Send to Poke",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        944,
        208
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "poke-api-key",
          "name": "Poke API Key"
        },
        "httpBearerAuth": {
          "id": "H3j7klwNJz7CiJaD",
          "name": "Bearer Auth account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Success handler\\nconst item = $input.item.json;\\n\\nconsole.log('âœ… Successfully sent to Poke');\\nconsole.log('Response:', JSON.stringify(item, null, 2));\\n\\nreturn {\\n  json: {\\n    success: true,\\n    status: item.statusCode || 200,\\n    message: 'Location update sent to Poke',\\n    timestamp: new Date().toISOString()\\n  }\\n};"
      },
      "id": "log-success",
      "name": "Log Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        208
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Skipped handler\\nconst item = $input.item.json;\\n\\nconsole.log('â­ï¸  Location update skipped');\\nconsole.log('Reason:', item.reason || 'No reason provided');\\n\\nreturn {\\n  json: {\\n    skipped: true,\\n    reason: item.reason,\\n    timestamp: new Date().toISOString()\\n  }\\n};"
      },
      "id": "log-skipped",
      "name": "Log Skipped",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        400
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Error handler\\nconst error = $input.item.json;\\n\\nconsole.error('âŒ Error processing location update');\\nconsole.error('Error:', JSON.stringify(error, null, 2));\\n\\n// Return error details\\nreturn {\\n  json: {\\n    error: true,\\n    message: error.message || 'Unknown error',\\n    details: error,\\n    timestamp: new Date().toISOString()\\n  }\\n};"
      },
      "id": "handle-error",
      "name": "Handle Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        304
      ]
    }
  ],
  "connections": {
    "Webhook - Owntracks": {
      "main": [
        [
          {
            "node": "Filter Location Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Location Data": {
      "main": [
        [
          {
            "node": "Should Send?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Send?": {
      "main": [
        [
          {
            "node": "Format for Poke Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Poke Webhook": {
      "main": [
        [
          {
            "node": "Send to Poke",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Poke": {
      "main": [
        [
          {
            "node": "Log Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "errorWorkflow": "",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
  "activeVersionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
  "versionCounter": 166,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-02-18T19:31:58.200Z",
      "createdAt": "2026-02-18T19:31:58.200Z",
      "role": "workflow:owner",
      "workflowId": "lOVfBNjOpIc3hZxZ",
      "projectId": "TilHgTxHPA8tqHO1",
      "project": {
        "updatedAt": "2025-11-18T19:41:27.899Z",
        "createdAt": "2025-11-07T20:39:42.351Z",
        "id": "TilHgTxHPA8tqHO1",
        "name": "Lina F <jordane.frechet@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-02-19T16:46:13.042Z",
    "createdAt": "2026-02-19T16:46:13.042Z",
    "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
    "workflowId": "lOVfBNjOpIc3hZxZ",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "owntracks",
          "options": {
            "rawBody": false
          }
        },
        "id": "webhook-owntracks",
        "name": "Webhook - Owntracks",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "position": [
          256,
          304
        ],
        "webhookId": "owntracks-location"
      },
      {
        "parameters": {
          "jsCode": "// Owntracks Location Data Filter and Transformer\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst MIN_ACCURACY = 50;  // meters\nconst MIN_DISTANCE = 20;  // meters\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// COMPREHENSIVE DATA EXTRACTION WITH DEBUGGING\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconsole.log('ğŸ” RAW INPUT STRUCTURE:');\nconsole.log('$input:', JSON.stringify($input, null, 2));\nconsole.log('$input.all():', JSON.stringify($input.all(), null, 2));\n\n// Try multiple extraction methods\nlet item = null;\nlet extractionMethod = 'unknown';\n\n// Method 1: Direct json access\nif ($input.item && $input.item.json) {\n  item = $input.item.json;\n  extractionMethod = 'direct-json';\n  console.log('âœ“ Extracted via direct JSON access');\n}\n\n// Method 2: First item from all()\nif (!item && $input.all().length > 0) {\n  item = $input.all()[0].json;\n  extractionMethod = 'first-item-json';\n  console.log('âœ“ Extracted via first item JSON');\n}\n\n// Method 3: Check if data is in body\nif (!item && $input.item && $input.item.json && $input.item.json.body) {\n  item = $input.item.json.body;\n  extractionMethod = 'body-nested';\n  console.log('âœ“ Extracted via body nesting');\n}\n\n// Method 4: Check if data is in webhook payload\nif (!item && $input.item && $input.item.json && $input.item.json.payload) {\n  item = $input.item.json.payload;\n  extractionMethod = 'payload-nested';\n  console.log('âœ“ Extracted via payload nesting');\n}\n\n// Method 5: Direct access to raw data\nif (!item) {\n  item = $input.item || {};\n  extractionMethod = 'raw-item';\n  console.log('âœ“ Using raw item data');\n}\n\nconsole.log('ğŸ“ Extracted data via method:', extractionMethod);\nconsole.log('ğŸ“ Extracted item data:', JSON.stringify(item, null, 2));\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// FLEXIBLE COORDINATE EXTRACTION\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nfunction extractCoordinates(data) {\n  const possibilities = [\n    // Standard Owntracks format\n    { lat: data.lat, lon: data.lon },\n    { lat: data.latitude, lon: data.longitude },\n    \n    // Nested in location object\n    { lat: data.location?.lat, lon: data.location?.lon },\n    { lat: data.location?.latitude, lon: data.location?.longitude },\n    \n    // Query parameters (if webhook passes as query)\n    { lat: data.query?.lat, lon: data.query?.lon },\n    { lat: data.query?.latitude, lon: data.query?.longitude },\n    \n    // Body parameters\n    { lat: data.body?.lat, lon: data.body?.lon },\n    { lat: data.body?.latitude, lon: data.body?.longitude },\n    \n    // Headers (unlikely but possible)\n    { lat: data.headers?.lat, lon: data.headers?.lon },\n    { lat: data.headers?.latitude, lon: data.headers?.longitude },\n    \n    // Params\n    { lat: data.params?.lat, lon: data.params?.lon },\n    { lat: data.params?.latitude, lon: data.params?.longitude },\n  ];\n  \n  for (let i = 0; i < possibilities.length; i++) {\n    const coords = possibilities[i];\n    if (coords.lat !== undefined && coords.lon !== undefined && \n        coords.lat !== null && coords.lon !== null &&\n        !isNaN(parseFloat(coords.lat)) && !isNaN(parseFloat(coords.lon))) {\n      console.log(`âœ“ Found coordinates via method ${i + 1}: lat=${coords.lat}, lon=${coords.lon}`);\n      return {\n        latitude: parseFloat(coords.lat),\n        longitude: parseFloat(coords.lon)\n      };\n    }\n  }\n  \n  console.log('âŒ No valid coordinates found in any extraction method');\n  return { latitude: null, longitude: null };\n}\n\nconst coordinates = extractCoordinates(item);\n\n// Extract other Owntracks data with fallbacks\nconst data = {\n  type: item._type || item.type || 'location',\n  latitude: coordinates.latitude,\n  longitude: coordinates.longitude,\n  accuracy: parseFloat(item.acc || item.accuracy) || null,\n  timestamp: parseInt(item.tst || item.timestamp) || null,\n  altitude: parseFloat(item.alt || item.altitude) || null,\n  velocity: parseFloat(item.vel || item.velocity) || null,\n  battery: parseInt(item.batt || item.battery) || null,\n  tracker_id: item.tid || item.tracker_id || item.trackerId || null,\n  trigger: item.t || item.trigger || null\n};\n\nconsole.log('ğŸ¯ Processed data:', JSON.stringify(data, null, 2));\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// VALIDATION\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst validationErrors = [];\n\nif (data.latitude === null || data.longitude === null) {\n  validationErrors.push(`Missing latitude or longitude - lat: ${data.latitude}, lon: ${data.longitude}`);\n  console.log('âŒ Available keys in item:', Object.keys(item));\n  console.log('âŒ Item structure analysis:');\n  for (const key in item) {\n    console.log(`  ${key}: ${typeof item[key]} = ${JSON.stringify(item[key])}`);\n  }\n}\n\nif (data.latitude !== null && (data.latitude < -90 || data.latitude > 90)) {\n  validationErrors.push('Invalid latitude: ' + data.latitude);\n}\n\nif (data.longitude !== null && (data.longitude < -180 || data.longitude > 180)) {\n  validationErrors.push('Invalid longitude: ' + data.longitude);\n}\n\nif (validationErrors.length > 0) {\n  console.error('âŒ Validation errors:', validationErrors);\n  return {\n    json: {\n      error: 'Validation failed',\n      details: validationErrors,\n      extraction_method: extractionMethod,\n      available_keys: Object.keys(item),\n      raw_data: item,\n      skip: true\n    }\n  };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// FILTERING LOGIC\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst shouldSkip = [];\n\n// Filter 1: GPS Accuracy\nif (data.accuracy && data.accuracy > MIN_ACCURACY) {\n  shouldSkip.push(`Low accuracy: ${data.accuracy}m > ${MIN_ACCURACY}m`);\n}\n\n// Filter 2: Ignore certain trigger types if needed\nconst ignoredTriggers = [];  // e.g., ['p'] to ignore pings\n\nif (data.trigger && ignoredTriggers.includes(data.trigger)) {\n  shouldSkip.push(`Ignored trigger type: ${data.trigger}`);\n}\n\nif (shouldSkip.length > 0) {\n  console.log('â­ï¸  Skipping location update:', shouldSkip);\n  return {\n    json: {\n      skip: true,\n      reason: shouldSkip,\n      data: data\n    }\n  };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// TRANSFORM FOR POKE\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// Convert timestamp to ISO format\nconst timestamp = data.timestamp\n  ? new Date(data.timestamp * 1000).toISOString()\n  : new Date().toISOString();\n\n// Format data for Poke API\nconst pokePayload = {\n  type: 'location_update',\n  source: 'owntracks',\n  timestamp: timestamp,\n  location: {\n    latitude: data.latitude,\n    longitude: data.longitude,\n    accuracy: data.accuracy,\n    altitude: data.altitude,\n    velocity: data.velocity\n  },\n  device: {\n    tracker_id: data.tracker_id,\n    battery: data.battery,\n    trigger: data.trigger\n  },\n  metadata: {\n    raw_timestamp: data.timestamp,\n    processed_at: new Date().toISOString(),\n    extraction_method: extractionMethod\n  }\n};\n\nconsole.log('âœ… Location update passed filters');\nconsole.log('ğŸ“¤ Sending to Poke:', JSON.stringify(pokePayload, null, 2));\n\nreturn {\n  json: {\n    skip: false,\n    source: 'owntracks',\n    type: data.type,\n    coordinates: {\n      latitude: data.latitude,\n      longitude: data.longitude\n    },\n    device: {\n      tracker_id: data.tracker_id,\n      battery: data.battery\n    },\n    extraction_method: extractionMethod,\n    poke_payload: pokePayload,\n    original_data: data\n  }\n};"
        },
        "id": "filter-location",
        "name": "Filter Location Data",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          464,
          304
        ]
      },
      {
        "parameters": {
          "conditions": {
            "boolean": [
              {
                "value1": "={{ $json.skip }}"
              }
            ]
          }
        },
        "id": "check-skip",
        "name": "Should Send?",
        "type": "n8n-nodes-base.if",
        "typeVersion": 1,
        "position": [
          656,
          304
        ]
      },
      {
        "parameters": {
          "jsCode": "// Format for Poke Webhook - Improved with Edge Case Handling\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\ntry {\n  // Validate input exists\n  const item = $input.first();\n  \n  if (!item) {\n    console.error('âŒ No input data received');\n    return [{\n      json: {\n        message: JSON.stringify({\n          error: 'No input data',\n          source: \"owntracks\",\n          timestamp: new Date().toISOString()\n        })\n      }\n    }];\n  }\n\n  console.log('ğŸ“¥ Input data:', JSON.stringify(item, null, 2));\n\n  // Safely extract data with defaults\n  const json = item.json || {};\n  \n  // Validate required fields exist\n  const source = json.source || 'owntracks';\n  const type = json.type || 'location';\n  \n  // Safely extract coordinates with validation\n  const coordinates = json.coordinates || {};\n  const hasValidCoordinates = \n    coordinates.latitude !== undefined && \n    coordinates.longitude !== undefined &&\n    coordinates.latitude !== null &&\n    coordinates.longitude !== null &&\n    !isNaN(coordinates.latitude) &&\n    !isNaN(coordinates.longitude);\n  \n  if (!hasValidCoordinates) {\n    console.error('âŒ Invalid or missing coordinates:', coordinates);\n    return [{\n      json: {\n        message: JSON.stringify({\n          error: 'Invalid coordinates',\n          source: source,\n          received: coordinates,\n          timestamp: new Date().toISOString()\n        })\n      }\n    }];\n  }\n  \n  // Safely extract device info with defaults\n  const device = json.device || {};\n  const deviceData = {\n    tracker_id: device.tracker_id || null,\n    battery: device.battery !== undefined ? device.battery : null\n  };\n  \n  // Build the location data object\n  const locationData = {\n    source: source,\n    type: type,\n    coordinates: {\n      latitude: parseFloat(coordinates.latitude),\n      longitude: parseFloat(coordinates.longitude)\n    },\n    device: deviceData\n  };\n  \n  // Stringify and validate JSON output\n  let messageString;\n  try {\n    messageString = JSON.stringify(locationData);\n  } catch (stringifyError) {\n    console.error('âŒ Error stringifying location data:', stringifyError);\n    messageString = JSON.stringify({\n      error: 'Stringify failed',\n      source: source,\n      timestamp: new Date().toISOString()\n    });\n  }\n  \n  console.log('âœ… Formatted message for Poke:', messageString);\n  \n  // Return in the required format\n  return [{\n    json: {\n      message: messageString\n    }\n  }];\n  \n} catch (error) {\n  console.error('âŒ Unexpected error in Format for Poke Webhook:', error);\n  console.error('Error stack:', error.stack);\n  console.error('Input data:', JSON.stringify($input.all(), null, 2));\n  \n  // Always return valid format even on error\n  return [{\n    json: {\n      message: JSON.stringify({\n        error: error.message || 'Unknown error',\n        source: \"owntracks\",\n        timestamp: new Date().toISOString(),\n        stack: error.stack\n      })\n    }\n  }];\n}"
        },
        "id": "format-poke-webhook",
        "name": "Format for Poke Webhook",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          784,
          208
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "=https://poke.com/api/v1/inbound-sms/webhook",
          "authentication": "genericCredentialType",
          "genericAuthType": "httpBearerAuth",
          "sendBody": true,
          "contentType": "raw",
          "body": "={{ JSON.stringify($json.message) }}",
          "options": {
            "response": {
              "response": {
                "fullResponse": true
              }
            },
            "timeout": 10000
          }
        },
        "id": "send-to-poke",
        "name": "Send to Poke",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4,
        "position": [
          944,
          208
        ],
        "credentials": {
          "httpHeaderAuth": {
            "id": "poke-api-key",
            "name": "Poke API Key"
          },
          "httpBearerAuth": {
            "id": "H3j7klwNJz7CiJaD",
            "name": "Bearer Auth account"
          }
        }
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Success handler\\nconst item = $input.item.json;\\n\\nconsole.log('âœ… Successfully sent to Poke');\\nconsole.log('Response:', JSON.stringify(item, null, 2));\\n\\nreturn {\\n  json: {\\n    success: true,\\n    status: item.statusCode || 200,\\n    message: 'Location update sent to Poke',\\n    timestamp: new Date().toISOString()\\n  }\\n};"
        },
        "id": "log-success",
        "name": "Log Success",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1136,
          208
        ]
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Skipped handler\\nconst item = $input.item.json;\\n\\nconsole.log('â­ï¸  Location update skipped');\\nconsole.log('Reason:', item.reason || 'No reason provided');\\n\\nreturn {\\n  json: {\\n    skipped: true,\\n    reason: item.reason,\\n    timestamp: new Date().toISOString()\\n  }\\n};"
        },
        "id": "log-skipped",
        "name": "Log Skipped",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          864,
          400
        ]
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// Error handler\\nconst error = $input.item.json;\\n\\nconsole.error('âŒ Error processing location update');\\nconsole.error('Error:', JSON.stringify(error, null, 2));\\n\\n// Return error details\\nreturn {\\n  json: {\\n    error: true,\\n    message: error.message || 'Unknown error',\\n    details: error,\\n    timestamp: new Date().toISOString()\\n  }\\n};"
        },
        "id": "handle-error",
        "name": "Handle Error",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1136,
          304
        ]
      }
    ],
    "connections": {
      "Webhook - Owntracks": {
        "main": [
          [
            {
              "node": "Filter Location Data",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Location Data": {
        "main": [
          [
            {
              "node": "Should Send?",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Should Send?": {
        "main": [
          [
            {
              "node": "Format for Poke Webhook",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Log Skipped",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Format for Poke Webhook": {
        "main": [
          [
            {
              "node": "Send to Poke",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send to Poke": {
        "main": [
          [
            {
              "node": "Log Success",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Lina F",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-19T16:46:13.174Z",
        "id": 103,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "activated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:46:13.879Z",
        "id": 105,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "activated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:49:47.371Z",
        "id": 107,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "activated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:49:48.072Z",
        "id": 109,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "activated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:46:13.151Z",
        "id": 102,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "deactivated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:46:13.859Z",
        "id": 104,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "deactivated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:49:47.277Z",
        "id": 106,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "deactivated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      },
      {
        "createdAt": "2026-02-19T16:49:47.968Z",
        "id": 108,
        "workflowId": "lOVfBNjOpIc3hZxZ",
        "versionId": "8490bf4b-d110-4234-916c-5a064c0def9f",
        "event": "deactivated",
        "userId": "319eaa7a-83a0-4f1d-ba6e-595ef2af39b3"
      }
    ]
  }
}
