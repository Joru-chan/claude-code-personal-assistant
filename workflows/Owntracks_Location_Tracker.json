{
  "name": "Enhanced Owntracks Location Tracker",
  "description": "Advanced Owntracks workflow with distance filtering, rate limiting, and multi-type support",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "owntracks",
        "options": {
          "rawBody": false
        }
      },
      "id": "webhook-owntracks",
      "name": "Webhook - Owntracks",
      "type": "n8n-nodes-base.webhook",
      "position": [256, 304]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Enhanced Owntracks Location Data Filter and Transformer\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst item = $input.item.json;\n\n// CONFIGURABLE SETTINGS (Environment variables or workflow settings)\nconst CONFIG = {\n  MIN_ACCURACY: $env.OWNTRACKS_MIN_ACCURACY || 50,    // meters\n  MIN_DISTANCE: $env.OWNTRACKS_MIN_DISTANCE || 20,   // meters\n  MAX_AGE_MINUTES: $env.OWNTRACKS_MAX_AGE || 15,     // minutes\n  RATE_LIMIT_WINDOW: $env.OWNTRACKS_RATE_WINDOW || 5, // minutes\n  MAX_UPDATES_PER_WINDOW: $env.OWNTRACKS_MAX_UPDATES || 10,\n  MIN_BATTERY: $env.OWNTRACKS_MIN_BATTERY || 10,     // percentage\n  MAX_VELOCITY: $env.OWNTRACKS_MAX_VELOCITY || 200,  // km/h\n  IGNORED_TRIGGERS: ($env.OWNTRACKS_IGNORED_TRIGGERS || '').split(',').filter(t => t)\n};\n\nconsole.log('ğŸ“ Received Owntracks data:', JSON.stringify(item, null, 2));\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// EXTRACT AND NORMALIZE DATA BY TYPE\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst messageType = item._type || 'location';\nlet data = {};\n\nswitch (messageType) {\n  case 'location':\n    data = {\n      type: 'location',\n      latitude: item.lat,\n      longitude: item.lon,\n      accuracy: item.acc,\n      timestamp: item.tst,\n      altitude: item.alt,\n      velocity: item.vel,\n      battery: item.batt,\n      tracker_id: item.tid,\n      trigger: item.t\n    };\n    break;\n    \n  case 'transition':\n    data = {\n      type: 'transition',\n      event: item.event, // 'enter' or 'leave'\n      description: item.desc,\n      latitude: item.lat,\n      longitude: item.lon,\n      accuracy: item.acc,\n      timestamp: item.tst,\n      tracker_id: item.tid,\n      radius: item.rad\n    };\n    break;\n    \n  case 'waypoint':\n    data = {\n      type: 'waypoint',\n      latitude: item.lat,\n      longitude: item.lon,\n      radius: item.rad,\n      description: item.desc,\n      timestamp: item.tst,\n      tracker_id: item.tid,\n      shared: item.shared\n    };\n    break;\n    \n  default:\n    console.log(`âš ï¸ Unsupported message type: ${messageType}`);\n    return {\n      json: {\n        skip: true,\n        reason: [`Unsupported message type: ${messageType}`]\n      }\n    };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// VALIDATION\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst validationErrors = [];\nconst now = Math.floor(Date.now() / 1000);\n\n// Basic coordinate validation for location-based messages\nif (data.latitude !== undefined && data.longitude !== undefined) {\n  if (!data.latitude || !data.longitude) {\n    validationErrors.push('Missing latitude or longitude');\n  }\n  if (data.latitude < -90 || data.latitude > 90) {\n    validationErrors.push(`Invalid latitude: ${data.latitude}`);\n  }\n  if (data.longitude < -180 || data.longitude > 180) {\n    validationErrors.push(`Invalid longitude: ${data.longitude}`);\n  }\n}\n\n// Timestamp validation\nif (data.timestamp) {\n  const ageMinutes = (now - data.timestamp) / 60;\n  if (ageMinutes > CONFIG.MAX_AGE_MINUTES) {\n    validationErrors.push(`Data too old: ${ageMinutes.toFixed(1)} minutes`);\n  }\n  if (data.timestamp > now + 300) { // 5 minutes in future\n    validationErrors.push('Timestamp in future');\n  }\n}\n\n// Battery level validation (if available)\nif (data.battery !== undefined && data.battery < CONFIG.MIN_BATTERY) {\n  console.log(`âš ï¸ Low battery warning: ${data.battery}%`);\n}\n\n// Velocity reasonability check\nif (data.velocity !== undefined && data.velocity > CONFIG.MAX_VELOCITY) {\n  validationErrors.push(`Unreasonable velocity: ${data.velocity} km/h`);\n}\n\nif (validationErrors.length > 0) {\n  console.log('âŒ Validation errors:', validationErrors);\n  return {\n    json: {\n      error: 'Validation failed',\n      details: validationErrors,\n      skip: true\n    }\n  };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// STATE MANAGEMENT AND FILTERING\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// Get current workflow static data (persistent state)\nlet state = $workflow.staticData || {\n  lastLocation: null,\n  rateLimitWindow: [],\n  stats: { total: 0, sent: 0, skipped: 0 }\n};\n\nconst shouldSkip = [];\n\n// Rate limiting\nconst windowStart = now - (CONFIG.RATE_LIMIT_WINDOW * 60);\nstate.rateLimitWindow = state.rateLimitWindow.filter(ts => ts > windowStart);\n\nif (state.rateLimitWindow.length >= CONFIG.MAX_UPDATES_PER_WINDOW) {\n  shouldSkip.push(`Rate limit exceeded: ${state.rateLimitWindow.length}/${CONFIG.MAX_UPDATES_PER_WINDOW} in ${CONFIG.RATE_LIMIT_WINDOW}min`);\n}\n\n// Location-specific filtering\nif (data.type === 'location') {\n  // GPS Accuracy filter\n  if (data.accuracy && data.accuracy > CONFIG.MIN_ACCURACY) {\n    shouldSkip.push(`Low accuracy: ${data.accuracy}m > ${CONFIG.MIN_ACCURACY}m`);\n  }\n  \n  // Distance-based deduplication\n  if (state.lastLocation && CONFIG.MIN_DISTANCE > 0) {\n    const distance = calculateDistance(\n      state.lastLocation.latitude,\n      state.lastLocation.longitude,\n      data.latitude,\n      data.longitude\n    );\n    \n    if (distance < CONFIG.MIN_DISTANCE) {\n      shouldSkip.push(`Too close to last location: ${distance.toFixed(1)}m < ${CONFIG.MIN_DISTANCE}m`);\n    }\n  }\n  \n  // Trigger type filtering\n  if (data.trigger && CONFIG.IGNORED_TRIGGERS.includes(data.trigger)) {\n    shouldSkip.push(`Ignored trigger type: ${data.trigger}`);\n  }\n}\n\n// Always allow transition and waypoint events (they're important)\nif (data.type === 'transition' || data.type === 'waypoint') {\n  console.log(`ğŸ“ ${data.type} event - bypassing distance/rate filters`);\n  shouldSkip.length = 0; // Clear skip reasons\n}\n\n// Update statistics\nstate.stats.total++;\n\nif (shouldSkip.length > 0) {\n  state.stats.skipped++;\n  console.log('â­ï¸ Skipping update:', shouldSkip);\n  \n  // Update workflow state\n  $workflow.staticData = state;\n  \n  return {\n    json: {\n      skip: true,\n      reason: shouldSkip,\n      data: data,\n      stats: state.stats\n    }\n  };\n}\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// UPDATE STATE\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// Update last location (for distance calculations)\nif (data.type === 'location') {\n  state.lastLocation = {\n    latitude: data.latitude,\n    longitude: data.longitude,\n    timestamp: data.timestamp\n  };\n}\n\n// Update rate limit window\nstate.rateLimitWindow.push(now);\nstate.stats.sent++;\n\n// Save state\n$workflow.staticData = state;\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// TRANSFORM FOR POKE\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nconst timestamp = data.timestamp \n  ? new Date(data.timestamp * 1000).toISOString()\n  : new Date().toISOString();\n\n// Build payload based on message type\nlet pokePayload;\n\nswitch (data.type) {\n  case 'location':\n    pokePayload = {\n      type: 'location_update',\n      source: 'owntracks',\n      timestamp: timestamp,\n      location: {\n        latitude: data.latitude,\n        longitude: data.longitude,\n        accuracy: data.accuracy,\n        altitude: data.altitude,\n        velocity: data.velocity\n      },\n      device: {\n        tracker_id: data.tracker_id,\n        battery: data.battery,\n        trigger: data.trigger\n      }\n    };\n    break;\n    \n  case 'transition':\n    pokePayload = {\n      type: 'location_transition',\n      source: 'owntracks',\n      timestamp: timestamp,\n      transition: {\n        event: data.event,\n        description: data.description,\n        radius: data.radius\n      },\n      location: {\n        latitude: data.latitude,\n        longitude: data.longitude,\n        accuracy: data.accuracy\n      },\n      device: {\n        tracker_id: data.tracker_id\n      }\n    };\n    break;\n    \n  case 'waypoint':\n    pokePayload = {\n      type: 'location_waypoint',\n      source: 'owntracks',\n      timestamp: timestamp,\n      waypoint: {\n        description: data.description,\n        radius: data.radius,\n        shared: data.shared\n      },\n      location: {\n        latitude: data.latitude,\n        longitude: data.longitude\n      },\n      device: {\n        tracker_id: data.tracker_id\n      }\n    };\n    break;\n}\n\npokePayload.metadata = {\n  raw_timestamp: data.timestamp,\n  processed_at: new Date().toISOString(),\n  workflow_stats: state.stats\n};\n\nconsole.log('âœ… Update passed all filters');\nconsole.log('ğŸ“¤ Sending to Poke:', JSON.stringify(pokePayload, null, 2));\n\nreturn {\n  json: {\n    skip: false,\n    poke_payload: pokePayload,\n    original_data: data,\n    stats: state.stats\n  }\n};\n\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// HELPER FUNCTIONS\n// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n  const R = 6371000; // Earth's radius in meters\n  const dLat = toRadians(lat2 - lat1);\n  const dLon = toRadians(lon2 - lon1);\n  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *\n    Math.sin(dLon/2) * Math.sin(dLon/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c; // Distance in meters\n}\n\nfunction toRadians(degrees) {\n  return degrees * (Math.PI/180);\n}"
      },
      "id": "enhanced-filter",
      "name": "Enhanced Location Filter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [464, 304]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.skip }}"
            }
          ]
        }
      },
      "id": "check-skip",
      "name": "Should Send?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [656, 304]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://poke.com/api/v1/inbound-sms/webhook",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "body",
              "value": "={{ $json.poke_payload }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "fullResponse": true
            }
          },
          "timeout": 10000,
          "retry": {
            "enabled": true,
            "maxAttempts": 3,
            "waitBetween": 1000
          }
        }
      },
      "id": "send-to-poke",
      "name": "Send to Poke",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [864, 208]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const item = $input.item.json;\nconst response = item.body || item;\n\nconsole.log('âœ… Successfully sent to Poke');\nconsole.log('Response:', JSON.stringify(response, null, 2));\n\nreturn {\n  json: {\n    success: true,\n    status: item.statusCode || 200,\n    message: 'Update sent to Poke',\n    timestamp: new Date().toISOString(),\n    stats: response.workflow_stats || null\n  }\n};"
      },
      "id": "log-success",
      "name": "Log Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1056, 208]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const item = $input.item.json;\n\nconsole.log('â­ï¸ Update skipped');\nconsole.log('Reason:', item.reason || 'No reason provided');\nconsole.log('Stats:', item.stats || 'No stats available');\n\nreturn {\n  json: {\n    skipped: true,\n    reason: item.reason,\n    stats: item.stats,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "log-skipped",
      "name": "Log Skipped",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [864, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const error = $input.item.json;\n\nconsole.error('âŒ Error processing update');\nconsole.error('Error:', JSON.stringify(error, null, 2));\n\n// Extract meaningful error information\nconst errorMessage = error.message || \n  error.error?.message ||\n  (error.cause && JSON.stringify(error.cause)) ||\n  'Unknown error';\n\nreturn {\n  json: {\n    error: true,\n    message: errorMessage,\n    details: error,\n    timestamp: new Date().toISOString(),\n    // Add context for debugging\n    context: {\n      statusCode: error.statusCode,\n      url: error.config?.url,\n      method: error.config?.method\n    }\n  }\n};"
      },
      "id": "handle-error",
      "name": "Handle Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1056, 304]
    }
  ],
  "connections": {
    "Webhook - Owntracks": {
      "main": [
        [
          {
            "node": "Enhanced Location Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced Location Filter": {
      "main": [
        [
          {
            "node": "Should Send?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Send?": {
      "main": [
        [
          {
            "node": "Send to Poke",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Poke": {
      "main": [
        [
          {
            "node": "Log Success",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Handle Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": {}
}