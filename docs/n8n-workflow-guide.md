# n8n Workflow Guide

> A comprehensive guide for working with n8n workflows in this repository

## Table of Contents

1. [Workflow Architecture Best Practices](#workflow-architecture-best-practices)
2. [Code Formatting in n8n](#code-formatting-in-n8n)
3. [GitHub to n8n Sync](#github-to-n8n-sync)
4. [Owntracks Integration Specifics](#owntracks-integration-specifics)

---

## Workflow Architecture Best Practices

### Separation of Concerns

A well-designed n8n workflow separates different responsibilities into distinct nodes. This makes workflows easier to debug, maintain, and understand.

#### Core Principles

1. **Filter Logic** - Dedicated nodes for conditionals and routing
2. **Data Transformation** - Separate nodes for data manipulation
3. **HTTP Requests** - Isolated nodes for external API calls

#### Example Structure

```
Webhook Trigger
    ↓
Data Validation (Filter/Switch)
    ↓
Data Transformation (Set/Code)
    ↓
Format for Specific Service
    ↓
HTTP Request
    ↓
Error Handling
```

### The Importance of the Format for Poke Webhook Node

The "Format for Poke Webhook" node (or similar formatting nodes) serves as a **critical adapter layer** between your data processing and external service expectations.

**Why it's essential:**

- **Data Contract Enforcement**: Ensures data matches the exact structure expected by the downstream service
- **Decoupling**: Isolates service-specific formatting from general business logic
- **Maintainability**: Changes to the Poke API only require updating this single node
- **Debugging**: Makes it easy to inspect the exact payload being sent

**Example Format Node:**

```javascript
// Format for Poke Webhook
return {
  latitude: items[0].json.latitude,
  longitude: items[0].json.longitude,
  timestamp: items[0].json.timestamp,
  accuracy: items[0].json.accuracy || 0,
  // Explicitly structure data for the Poke API
  metadata: {
    source: 'owntracks',
    device: items[0].json.tid || 'unknown'
  }
};
```

### Proper Data Flow Between Nodes

**Golden Rules:**

1. **Always use explicit field mapping** - Don't rely on passthrough unless intentional
2. **Validate data at boundaries** - Check inputs from webhooks and external APIs
3. **Transform early** - Convert data to working format as soon as possible
4. **Format late** - Apply service-specific formatting just before sending

**Anti-pattern:**
```
Webhook → HTTP Request (with complex inline transformations)
```

**Better pattern:**
```
Webhook → Validate → Transform → Format → HTTP Request
```

---

## Code Formatting in n8n

### The `\n` vs `\\n` Problem

**Critical Rule**: In n8n JSON fields, use **single backslash** `\n` for newlines, not double backslash `\\n`.

#### ❌ Wrong (will produce literal "\\n" in output):

```json
{
  "message": "Line 1\\nLine 2\\nLine 3"
}
```

Output: `Line 1\nLine 2\nLine 3` (literal backslash-n)

#### ✅ Correct:

```json
{
  "message": "Line 1\nLine 2\nLine 3"
}
```

Output:
```
Line 1
Line 2
Line 3
```

### Multi-line Code Blocks

When working with code nodes or text fields that need to preserve formatting:

#### In JSON strings:

```json
{
  "code": "function process(data) {\n  const result = data.map(item => {\n    return item.value * 2;\n  });\n  return result;\n}"
}
```

#### In Code Nodes:

n8n Code nodes use actual JavaScript, so you can write naturally:

```javascript
// This is actual JavaScript, no need for \n escaping
const formatted = items.map(item => {
  return {
    name: item.json.name,
    value: item.json.value
  };
});

return formatted;
```

### Comment Syntax Issues

**Problem**: Comments in JSON are not supported by the JSON spec, but n8n's interface may allow them in some contexts.

#### Best Practices:

1. **In Code Nodes**: Use standard JavaScript comments
   ```javascript
   // Single line comment
   /* Multi-line
      comment */
   ```

2. **In JSON Fields**: Avoid comments entirely or use a description field
   ```json
   {
     "_comment": "This is a workaround for documentation",
     "actualField": "value"
   }
   ```

3. **In Expressions**: Use n8n's expression syntax
   ```javascript
   {{ $json.field }} // Expression to get field value
   ```

---

## GitHub to n8n Sync

### Handling Read-Only Properties

When syncing workflows from GitHub to n8n via API, certain fields are **read-only** and must be excluded from your payload.

#### Read-Only Fields:

- `id` - Auto-generated by n8n
- `createdAt` - Set on creation
- `updatedAt` - Automatically updated
- `versionId` - Managed by n8n's versioning system
- `active` - **Must use separate activation endpoint**
- `tags` - **Requires special handling via tags API**

#### Workflow Update Payload Structure:

```javascript
// ✅ CORRECT: Strip read-only fields before updating
const cleanWorkflow = {
  name: workflow.name,
  nodes: workflow.nodes,
  connections: workflow.connections,
  settings: workflow.settings,
  staticData: workflow.staticData,
  // DO NOT include: id, createdAt, updatedAt, versionId, active, tags
};

// Send to: PUT /workflows/:id
```

### Proper API Endpoints

n8n uses different endpoints for different operations:

#### 1. Update Workflow Definition:
```
PUT /api/v1/workflows/{id}
```
**Payload**: Workflow structure (without read-only fields)

#### 2. Activate/Deactivate Workflow:
```
PATCH /api/v1/workflows/{id}
```
**Payload**:
```json
{
  "active": true
}
```

#### 3. Create New Workflow:
```
POST /api/v1/workflows
```
**Payload**: Full workflow structure (n8n assigns id)

### Common Error Patterns and Solutions

#### Error: "Field 'id' is not allowed"

**Cause**: Trying to update workflow with read-only fields in payload

**Solution**: Strip read-only fields before API call
```javascript
const { id, createdAt, updatedAt, versionId, active, tags, ...cleanWorkflow } = workflowFromGithub;
// Now use cleanWorkflow for the API call
```

#### Error: "Workflow not found"

**Cause**: Using wrong workflow ID or workflow doesn't exist in n8n

**Solution**: 
1. List all workflows: `GET /api/v1/workflows`
2. Match by name or create new workflow if not found

#### Error: "Invalid JSON"

**Cause**: Workflow file contains `\\n` or malformed JSON

**Solution**: Validate JSON before sending
```javascript
try {
  const workflow = JSON.parse(workflowContent);
  // Fix newlines if needed
  const fixed = JSON.stringify(workflow).replace(/\\\\n/g, '\\n');
  const finalWorkflow = JSON.parse(fixed);
} catch (error) {
  console.error('Invalid workflow JSON:', error);
}
```

#### Error: "Cannot activate inactive workflow"

**Cause**: Trying to set active: true in workflow update call

**Solution**: Use two-step process
```javascript
// Step 1: Update workflow structure
await updateWorkflow(workflowId, cleanWorkflow);

// Step 2: Activate separately (if needed)
await fetch(`/api/v1/workflows/${workflowId}`, {
  method: 'PATCH',
  body: JSON.stringify({ active: true })
});
```

### Complete Sync Script Example

```javascript
async function syncWorkflowFromGithub(githubWorkflow, n8nApiUrl, apiKey) {
  // 1. Clean the workflow
  const { id, createdAt, updatedAt, versionId, active, tags, ...clean } = githubWorkflow;
  
  // 2. Find existing workflow by name
  const existing = await fetch(`${n8nApiUrl}/workflows`).then(r => r.json());
  const match = existing.data.find(w => w.name === clean.name);
  
  if (match) {
    // Update existing
    await fetch(`${n8nApiUrl}/workflows/${match.id}`, {
      method: 'PUT',
      headers: {
        'X-N8N-API-KEY': apiKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(clean)
    });
    
    // Restore active state if it was active
    if (active) {
      await fetch(`${n8nApiUrl}/workflows/${match.id}`, {
        method: 'PATCH',
        headers: {
          'X-N8N-API-KEY': apiKey,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ active: true })
      });
    }
  } else {
    // Create new (active state can be included on creation)
    await fetch(`${n8nApiUrl}/workflows`, {
      method: 'POST',
      headers: {
        'X-N8N-API-KEY': apiKey,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ ...clean, active: active || false })
    });
  }
}
```

---

## Owntracks Integration Specifics

### Data Structure Expectations

Owntracks sends location data via HTTP POST with a specific JSON structure. Understanding this is crucial for proper integration.

#### Standard Owntracks Payload:

```json
{
  "_type": "location",
  "tid": "XX",
  "lat": 48.8566,
  "lon": 2.3522,
  "tst": 1645564800,
  "acc": 20,
  "batt": 85,
  "bs": 0,
  "conn": "w",
  "t": "u"
}
```

#### Field Descriptions:

| Field | Description | Type | Required |
|-------|-------------|------|----------|
| `_type` | Message type (usually "location") | string | Yes |
| `tid` | Tracker ID (device identifier) | string | Yes |
| `lat` | Latitude | number | Yes |
| `lon` | Longitude | number | Yes |
| `tst` | Timestamp (Unix epoch) | number | Yes |
| `acc` | Accuracy in meters | number | No |
| `batt` | Battery level (0-100) | number | No |
| `bs` | Battery status (0=unknown, 1=unplugged, 2=charging, 3=full) | number | No |
| `conn` | Connection type (w=wifi, m=mobile) | string | No |
| `t` | Trigger (u=user, p=ping, etc.) | string | No |

### Coordinate Handling

**Important**: Owntracks uses separate `lat` and `lon` fields, not a combined coordinate object.

#### Transform for Internal Use:

```javascript
// n8n Code Node - Transform Owntracks to standard format
const items = $input.all();

return items.map(item => {
  const data = item.json;
  
  return {
    json: {
      latitude: data.lat,
      longitude: data.lon,
      timestamp: new Date(data.tst * 1000).toISOString(), // Convert Unix to ISO
      accuracy: data.acc || 0,
      device: data.tid,
      batteryLevel: data.batt,
      trigger: data.t || 'unknown'
    }
  };
});
```

### Format Expected by Poke Webhook

The Poke webhook expects a specific format that may differ from Owntracks' native format.

#### Example Format for Poke Node:

```javascript
// Format for Poke Webhook node
const item = items[0].json;

return [{
  json: {
    latitude: item.latitude,
    longitude: item.longitude,
    timestamp: item.timestamp,
    accuracy: item.accuracy,
    // Poke-specific fields
    source: "owntracks",
    device_id: item.device,
    metadata: {
      battery: item.batteryLevel,
      trigger: item.trigger
    }
  }
}];
```

### Complete Owntracks → Poke Workflow

```
┌─────────────────────┐
│  Webhook Trigger    │
│  (Receive Owntracks)│
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Validate Data      │
│  (IF node)          │
│  Check: lat, lon,   │
│  tst exist          │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Transform          │
│  (Code Node)        │
│  Owntracks → Std    │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Format for Poke    │
│  (Code Node)        │
│  Std → Poke Format  │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  HTTP Request       │
│  POST to Poke API   │
└─────────────────────┘
```

#### Node Details:

**1. Webhook Trigger:**
- Path: `/owntracks`
- Method: POST
- Response: 200 OK

**2. Validate Data:**
```javascript
// IF node condition
{{ $json.lat !== undefined && $json.lon !== undefined && $json.tst !== undefined }}
```

**3. Transform:**
```javascript
// See "Transform for Internal Use" above
```

**4. Format for Poke:**
```javascript
// See "Format Expected by Poke Webhook" above
```

**5. HTTP Request:**
- Method: POST
- URL: `https://your-poke-api.com/location`
- Headers: `{ "Authorization": "Bearer YOUR_TOKEN" }`
- Body: `{{ $json }}`

### Common Owntracks Issues

#### Issue: Coordinates appear as "undefined"

**Cause**: Using `latitude`/`longitude` instead of `lat`/`lon`

**Solution**: Check the raw webhook payload and map correctly

#### Issue: Timestamp is wrong

**Cause**: Owntracks sends Unix timestamp (seconds), not milliseconds

**Solution**: Multiply by 1000 or use `new Date(tst * 1000)`

#### Issue: Some location updates missing

**Cause**: Validation node is too strict or Owntracks sent different message type

**Solution**: Check for `_type` field and handle different message types:
```javascript
if (item.json._type === 'location') {
  // Handle location
} else if (item.json._type === 'transition') {
  // Handle geofence transition
}
```

---

## Quick Reference

### Checklist for New Workflows

- [ ] Separate concerns (filter, transform, format, request)
- [ ] Use `\n` not `\\n` for newlines
- [ ] Add format node before external API calls
- [ ] Validate incoming webhook data
- [ ] Handle errors gracefully

### Checklist for GitHub Sync

- [ ] Remove read-only fields (id, createdAt, updatedAt, versionId)
- [ ] Handle `active` field separately via PATCH endpoint
- [ ] Handle `tags` separately if needed
- [ ] Test workflow JSON validity before syncing
- [ ] Match workflows by name, not ID

### Checklist for Owntracks Integration

- [ ] Webhook accepts POST requests
- [ ] Transform `lat`/`lon` to your standard format
- [ ] Convert Unix timestamp (tst) to ISO or milliseconds
- [ ] Handle missing optional fields (acc, batt, etc.)
- [ ] Format data specifically for Poke webhook
- [ ] Test with actual Owntracks device or simulator

---

## Additional Resources

- [n8n Official Documentation](https://docs.n8n.io/)
- [n8n API Documentation](https://docs.n8n.io/api/)
- [Owntracks JSON Documentation](https://owntracks.org/booklet/tech/json/)
- [n8n Community Forum](https://community.n8n.io/)

---

**Last Updated**: February 2026  
**Maintainer**: Jordane Frechet  
**Repository**: Joru-chan/assistant